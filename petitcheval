#!/usr/bin/env python3
"""petitcheval — a hierarchical TODO TUI & CLI using ncurses and SQLite.

Hierarchy: workspace (project) → task (feature/effort) → step (checklist item)
"""

import curses
import json
import os
import sqlite3
import sys
from datetime import datetime

DB_PATH = os.path.join(os.path.expanduser("~"), ".todo.db")


# ── Database ────────────────────────────────────────────────────────────────

def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.execute("PRAGMA foreign_keys = ON")

    conn.execute(
        """CREATE TABLE IF NOT EXISTS workspaces (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE,
            created_at TEXT NOT NULL
        )"""
    )
    conn.execute(
        """CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
            name TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'active',
            created_at TEXT NOT NULL
        )"""
    )
    conn.execute(
        """CREATE TABLE IF NOT EXISTS steps (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            task_id INTEGER NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
            text TEXT NOT NULL,
            done INTEGER NOT NULL DEFAULT 0,
            priority TEXT NOT NULL DEFAULT 'medium',
            created_at TEXT NOT NULL,
            completed_at TEXT
        )"""
    )

    # ── Migration: adopt old flat todos into default workspace/task ──
    has_old = False
    try:
        conn.execute("SELECT 1 FROM todos LIMIT 1")
        has_old = True
    except sqlite3.OperationalError:
        pass

    if has_old:
        now = datetime.now().isoformat()
        row = conn.execute("SELECT id FROM workspaces WHERE name = 'default'").fetchone()
        if row:
            ws_id = row[0]
        else:
            cur = conn.execute("INSERT INTO workspaces (name, created_at) VALUES ('default', ?)", (now,))
            ws_id = cur.lastrowid

        row = conn.execute("SELECT id FROM tasks WHERE workspace_id = ? AND name = 'default'", (ws_id,)).fetchone()
        if row:
            task_id = row[0]
        else:
            cur = conn.execute(
                "INSERT INTO tasks (workspace_id, name, status, created_at) VALUES (?, 'default', 'active', ?)",
                (ws_id, now),
            )
            task_id = cur.lastrowid

        # Copy old todos → steps
        old_todos = conn.execute("SELECT task, done, priority, created_at, completed_at FROM todos").fetchall()
        for t in old_todos:
            conn.execute(
                "INSERT INTO steps (task_id, text, done, priority, created_at, completed_at) VALUES (?, ?, ?, ?, ?, ?)",
                (task_id, t[0], t[1], t[2], t[3], t[4]),
            )
        conn.execute("DROP TABLE todos")
        conn.commit()

    # Also handle previous plan-based schema migration
    has_plans = False
    try:
        conn.execute("SELECT 1 FROM plans LIMIT 1")
        has_plans = True
    except sqlite3.OperationalError:
        pass

    if has_plans:
        now = datetime.now().isoformat()
        # Migrate each workspace's plans → tasks, and todos → steps
        plans = conn.execute(
            "SELECT p.id, p.workspace_id, p.name, p.status, p.created_at FROM plans p"
        ).fetchall()
        for plan in plans:
            plan_id, ws_id, pname, pstatus, pcreated = plan
            # Create corresponding task if it doesn't already exist
            existing = conn.execute(
                "SELECT id FROM tasks WHERE workspace_id = ? AND name = ?", (ws_id, pname)
            ).fetchone()
            if existing:
                new_task_id = existing[0]
            else:
                cur = conn.execute(
                    "INSERT INTO tasks (workspace_id, name, status, created_at) VALUES (?, ?, ?, ?)",
                    (ws_id, pname, pstatus, pcreated),
                )
                new_task_id = cur.lastrowid
            # Check if old todos table has plan_id column
            try:
                old_todos = conn.execute(
                    "SELECT task, done, priority, created_at, completed_at FROM todos WHERE plan_id = ?",
                    (plan_id,),
                ).fetchall()
                for t in old_todos:
                    conn.execute(
                        "INSERT INTO steps (task_id, text, done, priority, created_at, completed_at) VALUES (?, ?, ?, ?, ?, ?)",
                        (new_task_id, t[0], t[1], t[2], t[3], t[4]),
                    )
            except sqlite3.OperationalError:
                pass
        try:
            conn.execute("DROP TABLE todos")
        except sqlite3.OperationalError:
            pass
        conn.execute("DROP TABLE plans")
        conn.commit()

    # Ensure at least one workspace exists
    if not conn.execute("SELECT 1 FROM workspaces LIMIT 1").fetchone():
        now = datetime.now().isoformat()
        conn.execute("INSERT INTO workspaces (name, created_at) VALUES ('default', ?)", (now,))
        conn.commit()

    return conn


# ── Data helpers ────────────────────────────────────────────────────────────

def resolve_workspace(db, name_or_id):
    if name_or_id.isdigit():
        return db.execute("SELECT id, name, created_at FROM workspaces WHERE id = ?", (int(name_or_id),)).fetchone()
    return db.execute("SELECT id, name, created_at FROM workspaces WHERE name = ?", (name_or_id,)).fetchone()


def get_tasks(db, workspace_id, status_filter=None):
    if status_filter:
        return db.execute(
            "SELECT id, workspace_id, name, status, created_at FROM tasks "
            "WHERE workspace_id = ? AND status = ? ORDER BY id",
            (workspace_id, status_filter),
        ).fetchall()
    return db.execute(
        "SELECT id, workspace_id, name, status, created_at FROM tasks WHERE workspace_id = ? ORDER BY id",
        (workspace_id,),
    ).fetchall()


def get_steps(db, task_id, status_filter="all"):
    clause = ""
    if status_filter == "pending":
        clause = " AND done = 0"
    elif status_filter == "done":
        clause = " AND done = 1"
    return db.execute(
        f"SELECT id, task_id, text, done, priority, created_at, completed_at FROM steps "
        f"WHERE task_id = ?{clause} "
        f"ORDER BY done, CASE priority WHEN 'high' THEN 0 WHEN 'medium' THEN 1 ELSE 2 END, id",
        (task_id,),
    ).fetchall()


def step_counts(db, task_id):
    row = db.execute(
        "SELECT COUNT(*), SUM(done) FROM steps WHERE task_id = ?", (task_id,)
    ).fetchone()
    return row[0], int(row[1] or 0)


# ── CLI API ─────────────────────────────────────────────────────────────────

def cli_error(msg):
    print(json.dumps({"error": msg}), file=sys.stderr)
    sys.exit(1)


def cli_workspace(db, args):
    if not args:
        cli_error("Usage: petitcheval workspace <list|add|rm>")
    cmd, rest = args[0], args[1:]

    if cmd == "list":
        rows = db.execute("SELECT id, name, created_at FROM workspaces ORDER BY id").fetchall()
        print(json.dumps([{"id": r[0], "name": r[1], "created_at": r[2]} for r in rows]))

    elif cmd == "add":
        if not rest:
            cli_error("Usage: petitcheval workspace add <name>")
        name = rest[0]
        if db.execute("SELECT 1 FROM workspaces WHERE name = ?", (name,)).fetchone():
            cli_error(f"Workspace '{name}' already exists")
        now = datetime.now().isoformat()
        cur = db.execute("INSERT INTO workspaces (name, created_at) VALUES (?, ?)", (name, now))
        db.commit()
        print(json.dumps({"id": cur.lastrowid, "name": name, "created_at": now}))

    elif cmd == "rm":
        if not rest:
            cli_error("Usage: petitcheval workspace rm <id>")
        ws_id = int(rest[0])
        if not db.execute("SELECT 1 FROM workspaces WHERE id = ?", (ws_id,)).fetchone():
            cli_error(f"Workspace {ws_id} not found")
        db.execute("DELETE FROM workspaces WHERE id = ?", (ws_id,))
        db.commit()
        print(json.dumps({"deleted": ws_id}))

    else:
        cli_error(f"Unknown workspace command: {cmd}")


def cli_task(db, args):
    if not args:
        cli_error("Usage: petitcheval task <list|add|rm>")
    cmd, rest = args[0], args[1:]

    if cmd == "list":
        ws_id = None
        i = 0
        while i < len(rest):
            if rest[i] == "--workspace" and i + 1 < len(rest):
                ws = resolve_workspace(db, rest[i + 1])
                if not ws:
                    cli_error(f"Workspace '{rest[i + 1]}' not found")
                ws_id = ws[0]; i += 2
            else:
                i += 1
        if ws_id:
            rows = get_tasks(db, ws_id)
        else:
            rows = db.execute(
                "SELECT id, workspace_id, name, status, created_at FROM tasks ORDER BY id"
            ).fetchall()
        out = []
        for r in rows:
            total, done = step_counts(db, r[0])
            out.append({
                "id": r[0], "workspace_id": r[1], "name": r[2],
                "status": r[3], "created_at": r[4],
                "steps_total": total, "steps_done": done,
            })
        print(json.dumps(out))

    elif cmd == "add":
        if not rest:
            cli_error("Usage: petitcheval task add <name> --workspace <name|id>")
        name_parts = []
        ws_val = None
        i = 0
        while i < len(rest):
            if rest[i] == "--workspace" and i + 1 < len(rest):
                ws_val = rest[i + 1]; i += 2
            else:
                name_parts.append(rest[i]); i += 1
        if not name_parts:
            cli_error("Task name is required")
        if ws_val is None:
            cli_error("--workspace is required")
        ws = resolve_workspace(db, ws_val)
        if not ws:
            cli_error(f"Workspace '{ws_val}' not found")
        name = " ".join(name_parts)
        now = datetime.now().isoformat()
        cur = db.execute(
            "INSERT INTO tasks (workspace_id, name, status, created_at) VALUES (?, ?, 'active', ?)",
            (ws[0], name, now),
        )
        db.commit()
        print(json.dumps({"id": cur.lastrowid, "workspace_id": ws[0], "name": name, "status": "active", "created_at": now}))

    elif cmd == "rm":
        if not rest:
            cli_error("Usage: petitcheval task rm <id>")
        tid = int(rest[0])
        if not db.execute("SELECT 1 FROM tasks WHERE id = ?", (tid,)).fetchone():
            cli_error(f"Task {tid} not found")
        db.execute("DELETE FROM tasks WHERE id = ?", (tid,))
        db.commit()
        print(json.dumps({"deleted": tid}))

    else:
        cli_error(f"Unknown task command: {cmd}")


def cli_step(db, args):
    if not args:
        cli_error("Usage: petitcheval step <list|add|done|undone|edit|rm>")
    cmd, rest = args[0], args[1:]

    if cmd == "list":
        task_id = None
        ws_id = None
        status_filter = "all"
        i = 0
        while i < len(rest):
            if rest[i] == "--task" and i + 1 < len(rest):
                task_id = int(rest[i + 1]); i += 2
            elif rest[i] == "--workspace" and i + 1 < len(rest):
                ws = resolve_workspace(db, rest[i + 1])
                if not ws:
                    cli_error(f"Workspace '{rest[i + 1]}' not found")
                ws_id = ws[0]; i += 2
            elif rest[i] == "--status" and i + 1 < len(rest):
                status_filter = rest[i + 1]; i += 2
            else:
                i += 1

        if task_id:
            rows = get_steps(db, task_id, status_filter)
        elif ws_id:
            task_rows = get_tasks(db, ws_id)
            rows = []
            for t in task_rows:
                rows.extend(get_steps(db, t[0], status_filter))
        else:
            rows = db.execute(
                "SELECT id, task_id, text, done, priority, created_at, completed_at FROM steps ORDER BY id"
            ).fetchall()

        print(json.dumps([
            {"id": r[0], "task_id": r[1], "text": r[2], "done": bool(r[3]),
             "priority": r[4], "created_at": r[5], "completed_at": r[6]}
            for r in rows
        ]))

    elif cmd == "add":
        if not rest:
            cli_error("Usage: petitcheval step add <text> --task <id> [-p high|medium|low]")
        text_parts = []
        task_id = None
        priority = "medium"
        i = 0
        while i < len(rest):
            if rest[i] == "--task" and i + 1 < len(rest):
                task_id = int(rest[i + 1]); i += 2
            elif rest[i] == "-p" and i + 1 < len(rest):
                priority = rest[i + 1]; i += 2
            else:
                text_parts.append(rest[i]); i += 1
        if not text_parts:
            cli_error("Step text is required")
        if task_id is None:
            cli_error("--task is required")
        if not db.execute("SELECT 1 FROM tasks WHERE id = ?", (task_id,)).fetchone():
            cli_error(f"Task {task_id} not found")
        text = " ".join(text_parts)
        now = datetime.now().isoformat()
        cur = db.execute(
            "INSERT INTO steps (task_id, text, priority, created_at) VALUES (?, ?, ?, ?)",
            (task_id, text, priority, now),
        )
        db.commit()
        print(json.dumps({"id": cur.lastrowid, "task_id": task_id, "text": text, "priority": priority, "done": False}))

    elif cmd == "done":
        if not rest:
            cli_error("Usage: petitcheval step done <id>")
        sid = int(rest[0])
        if not db.execute("SELECT 1 FROM steps WHERE id = ?", (sid,)).fetchone():
            cli_error(f"Step {sid} not found")
        db.execute("UPDATE steps SET done = 1, completed_at = ? WHERE id = ?", (datetime.now().isoformat(), sid))
        db.commit()
        print(json.dumps({"id": sid, "done": True}))

    elif cmd == "undone":
        if not rest:
            cli_error("Usage: petitcheval step undone <id>")
        sid = int(rest[0])
        if not db.execute("SELECT 1 FROM steps WHERE id = ?", (sid,)).fetchone():
            cli_error(f"Step {sid} not found")
        db.execute("UPDATE steps SET done = 0, completed_at = NULL WHERE id = ?", (sid,))
        db.commit()
        print(json.dumps({"id": sid, "done": False}))

    elif cmd == "edit":
        if len(rest) < 2:
            cli_error("Usage: petitcheval step edit <id> <text>")
        sid = int(rest[0])
        new_text = " ".join(rest[1:])
        if not db.execute("SELECT 1 FROM steps WHERE id = ?", (sid,)).fetchone():
            cli_error(f"Step {sid} not found")
        db.execute("UPDATE steps SET text = ? WHERE id = ?", (new_text, sid))
        db.commit()
        print(json.dumps({"id": sid, "text": new_text}))

    elif cmd == "rm":
        if not rest:
            cli_error("Usage: petitcheval step rm <id>")
        sid = int(rest[0])
        if not db.execute("SELECT 1 FROM steps WHERE id = ?", (sid,)).fetchone():
            cli_error(f"Step {sid} not found")
        db.execute("DELETE FROM steps WHERE id = ?", (sid,))
        db.commit()
        print(json.dumps({"deleted": sid}))

    else:
        cli_error(f"Unknown step command: {cmd}")


# ── TUI ─────────────────────────────────────────────────────────────────────

def textbox_input(stdscr, prompt, prefill=""):
    h, w = stdscr.getmaxyx()
    y = h - 2
    stdscr.attron(curses.A_REVERSE)
    stdscr.addnstr(y, 0, " " * (w - 1), w - 1)
    stdscr.addnstr(y, 1, prompt, w - 2)
    stdscr.attroff(curses.A_REVERSE)
    stdscr.refresh()

    curses.curs_set(1)
    buf = list(prefill)
    cursor = len(buf)

    while True:
        input_y = y + 1
        stdscr.move(input_y, 0)
        stdscr.clrtoeol()
        display = "".join(buf)
        stdscr.addnstr(input_y, 1, display, w - 2)
        stdscr.move(input_y, 1 + cursor)
        stdscr.refresh()

        ch = stdscr.get_wch()
        if ch == "\n":
            curses.curs_set(0)
            return "".join(buf)
        elif ch == "\x1b":
            curses.curs_set(0)
            return None
        elif ch in (curses.KEY_BACKSPACE, "\x7f", "\b"):
            if cursor > 0:
                buf.pop(cursor - 1)
                cursor -= 1
        elif ch == curses.KEY_DC:
            if cursor < len(buf):
                buf.pop(cursor)
        elif ch == curses.KEY_LEFT:
            cursor = max(0, cursor - 1)
        elif ch == curses.KEY_RIGHT:
            cursor = min(len(buf), cursor + 1)
        elif ch == curses.KEY_HOME:
            cursor = 0
        elif ch == curses.KEY_END:
            cursor = len(buf)
        elif isinstance(ch, str) and len(ch) == 1 and ch.isprintable():
            buf.insert(cursor, ch)
            cursor += 1


def popup_select(stdscr, title, items, label_fn):
    """Centered popup list. Returns selected item or None on ESC."""
    h, w = stdscr.getmaxyx()
    box_w = min(w - 4, 50)
    box_h = min(h - 4, len(items) + 2)
    start_y = (h - box_h) // 2
    start_x = (w - box_w) // 2
    sel = 0
    scroll = 0
    inner_h = box_h - 2

    while True:
        for row in range(box_h):
            stdscr.addnstr(start_y + row, start_x, " " * box_w, box_w, curses.A_REVERSE)
        stdscr.addnstr(start_y, start_x + 1, title[:box_w - 2], box_w - 2, curses.A_REVERSE | curses.A_BOLD)

        for i in range(inner_h):
            idx = i + scroll
            if idx >= len(items):
                break
            label = label_fn(items[idx])[:box_w - 4]
            attr = curses.A_REVERSE
            if idx == sel:
                attr = curses.color_pair(1) | curses.A_BOLD
            stdscr.addnstr(start_y + 1 + i, start_x + 1, f" {label:<{box_w - 3}}", box_w - 2, attr)
        stdscr.refresh()

        ch = stdscr.get_wch()
        if ch == "\x1b":
            return None
        elif ch in ("k", curses.KEY_UP):
            sel = max(0, sel - 1)
            if sel < scroll:
                scroll = sel
        elif ch in ("j", curses.KEY_DOWN):
            sel = min(len(items) - 1, sel + 1)
            if sel >= scroll + inner_h:
                scroll = sel - inner_h + 1
        elif ch == "\n":
            return items[sel]


# ── Tree-view model ─────────────────────────────────────────────────────────
# The TUI renders a flat list of "rows" built from the task→step tree.
# Each row is a dict: {"type": "task"|"step", "data": ..., "task_id": ...}

def build_tree(db, workspace_id, collapsed):
    """Build flat row list from tasks + steps for the current workspace."""
    rows = []
    tasks = get_tasks(db, workspace_id, status_filter="active")
    for t in tasks:
        tid = t[0]
        total, done = step_counts(db, tid)
        rows.append({"type": "task", "id": tid, "name": t[2], "total": total, "done": done})
        if tid not in collapsed:
            steps = get_steps(db, tid)
            for s in steps:
                rows.append({
                    "type": "step", "id": s[0], "task_id": s[1],
                    "text": s[2], "done": s[3], "priority": s[4],
                })
    return rows


def draw_tree(stdscr, rows, cursor_pos, scroll_offset, status_msg, ws_name):
    stdscr.erase()
    h, w = stdscr.getmaxyx()

    TITLE = curses.color_pair(1) | curses.A_BOLD
    HIGH = curses.color_pair(2)
    MED = curses.color_pair(3)
    LOW = curses.color_pair(4)
    DIM = curses.color_pair(5)
    HELP = curses.color_pair(6)
    STATUS = curses.color_pair(7) | curses.A_BOLD
    SELECTED = curses.A_REVERSE
    priority_attr = {"high": HIGH, "medium": MED, "low": LOW}
    priority_icon = {"high": "!!!", "medium": " ! ", "low": " . "}

    # Title bar
    title = f" petitcheval  [{ws_name}] "
    stdscr.attron(TITLE)
    stdscr.addnstr(0, 0, " " * (w - 1), w - 1)
    stdscr.addnstr(0, 1, title[:w - 2], w - 2)
    stdscr.attroff(TITLE)

    # List area
    list_top = 2
    list_bottom = h - 3
    visible = list_bottom - list_top

    if not rows:
        msg = "No tasks yet. Press 'A' to add a task."
        stdscr.addnstr(list_top + 1, max(0, (w - len(msg)) // 2), msg, w - 1, DIM)
    else:
        for i in range(visible):
            idx = i + scroll_offset
            if idx >= len(rows):
                break
            row_y = list_top + i
            r = rows[idx]
            is_sel = idx == cursor_pos
            base = SELECTED if is_sel else 0

            stdscr.addnstr(row_y, 0, " " * (w - 1), w - 1, base)

            if r["type"] == "task":
                arrow = "▾" if True else "▸"  # collapsed state handled by presence of children
                count_s = f"[{r['done']}/{r['total']}]"
                # Check if all done
                all_done = r["total"] > 0 and r["done"] == r["total"]
                name_attr = base | (DIM if all_done else curses.A_BOLD)
                stdscr.addnstr(row_y, 1, arrow, 1, base)
                stdscr.addnstr(row_y, 3, r["name"][:w - 15], w - 15, name_attr)
                stdscr.addnstr(row_y, max(3, w - len(count_s) - 2), count_s, len(count_s),
                               base | (LOW if all_done else MED))
            else:
                # Step row — indented
                check = "[x]" if r["done"] else "[ ]"
                prio = r["priority"]
                ptag = priority_icon.get(prio, " ? ")
                text = r["text"]
                step_attr = base | (DIM if r["done"] else 0)

                stdscr.addnstr(row_y, 3, check, 3, step_attr)
                stdscr.addnstr(row_y, 7, ptag, 3, base | priority_attr.get(prio, 0))
                max_tw = w - 12
                stdscr.addnstr(row_y, 11, text[:max_tw], max_tw, step_attr)

    # Status message
    if status_msg:
        stdscr.attron(STATUS)
        stdscr.addnstr(h - 3, 0, " " * (w - 1), w - 1)
        stdscr.addnstr(h - 3, 1, status_msg[:w - 2], w - 2)
        stdscr.attroff(STATUS)

    # Help bar
    help_text = " A:new task  a:new step  enter:toggle  e:edit  p:priority  d:del  w:workspace  q:quit "
    stdscr.attron(HELP)
    stdscr.addnstr(h - 1, 0, " " * (w - 1), w - 1)
    stdscr.addnstr(h - 1, max(0, (w - len(help_text)) // 2), help_text[:w - 1], w - 1)
    stdscr.attroff(HELP)

    stdscr.refresh()


def tui_main(stdscr):
    curses.curs_set(0)
    stdscr.keypad(True)

    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_CYAN)
    curses.init_pair(2, curses.COLOR_RED, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_GREEN, -1)
    curses.init_pair(5, curses.COLOR_WHITE + 8 if curses.COLORS > 8 else curses.COLOR_WHITE, -1)
    curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(7, curses.COLOR_YELLOW, -1)

    db = get_db()

    # Pick initial workspace
    ws_row = db.execute("SELECT id, name FROM workspaces ORDER BY id LIMIT 1").fetchone()
    current_ws_id, current_ws_name = ws_row[0], ws_row[1]

    collapsed = set()  # task IDs that are collapsed
    cursor_pos = 0
    scroll_offset = 0
    status_msg = ""

    while True:
        rows = build_tree(db, current_ws_id, collapsed)
        h, w = stdscr.getmaxyx()
        visible = h - 5

        if rows:
            cursor_pos = max(0, min(cursor_pos, len(rows) - 1))
            if cursor_pos < scroll_offset:
                scroll_offset = cursor_pos
            if cursor_pos >= scroll_offset + visible:
                scroll_offset = cursor_pos - visible + 1
        else:
            cursor_pos = 0
            scroll_offset = 0

        draw_tree(stdscr, rows, cursor_pos, scroll_offset, status_msg, current_ws_name)
        status_msg = ""

        try:
            ch = stdscr.get_wch()
        except curses.error:
            continue

        if ch == "q" or ch == "Q":
            break

        elif ch == "k" or ch == curses.KEY_UP:
            cursor_pos = max(0, cursor_pos - 1)

        elif ch == "j" or ch == curses.KEY_DOWN:
            if rows:
                cursor_pos = min(len(rows) - 1, cursor_pos + 1)

        elif ch == "g":
            cursor_pos = 0

        elif ch == "G":
            if rows:
                cursor_pos = len(rows) - 1

        # Toggle collapse on task row / toggle done on step row
        elif ch == "\n" or ch == " ":
            if rows:
                r = rows[cursor_pos]
                if r["type"] == "task":
                    tid = r["id"]
                    if tid in collapsed:
                        collapsed.discard(tid)
                    else:
                        collapsed.add(tid)
                else:
                    sid = r["id"]
                    if r["done"]:
                        db.execute("UPDATE steps SET done = 0, completed_at = NULL WHERE id = ?", (sid,))
                    else:
                        db.execute(
                            "UPDATE steps SET done = 1, completed_at = ? WHERE id = ?",
                            (datetime.now().isoformat(), sid),
                        )
                    db.commit()
                    status_msg = f"{'Unchecked' if r['done'] else 'Completed'}: {r['text']}"

        # Add new task (A)
        elif ch == "A":
            name = textbox_input(stdscr, "New task name (ESC to cancel):")
            if name and name.strip():
                name = name.strip()
                now = datetime.now().isoformat()
                db.execute(
                    "INSERT INTO tasks (workspace_id, name, status, created_at) VALUES (?, ?, 'active', ?)",
                    (current_ws_id, name, now),
                )
                db.commit()
                status_msg = f"Created task: {name}"

        # Add step to current task (a)
        elif ch == "a":
            if rows:
                r = rows[cursor_pos]
                # Find which task we're in
                if r["type"] == "task":
                    task_id = r["id"]
                else:
                    task_id = r["task_id"]
                text = textbox_input(stdscr, "New step (ESC to cancel):")
                if text and text.strip():
                    text = text.strip()
                    now = datetime.now().isoformat()
                    db.execute(
                        "INSERT INTO steps (task_id, text, priority, created_at) VALUES (?, ?, 'medium', ?)",
                        (task_id, text, now),
                    )
                    db.commit()
                    # Make sure the task is expanded
                    collapsed.discard(task_id)
                    status_msg = f"Added: {text}"
            else:
                status_msg = "Create a task first (A)"

        # Edit
        elif ch == "e":
            if rows:
                r = rows[cursor_pos]
                if r["type"] == "task":
                    new_name = textbox_input(stdscr, "Edit task name:", prefill=r["name"])
                    if new_name and new_name.strip():
                        db.execute("UPDATE tasks SET name = ? WHERE id = ?", (new_name.strip(), r["id"]))
                        db.commit()
                        status_msg = "Updated task"
                else:
                    new_text = textbox_input(stdscr, "Edit step:", prefill=r["text"])
                    if new_text and new_text.strip():
                        db.execute("UPDATE steps SET text = ? WHERE id = ?", (new_text.strip(), r["id"]))
                        db.commit()
                        status_msg = "Updated step"

        # Delete
        elif ch == "d" or ch == curses.KEY_DC:
            if rows:
                r = rows[cursor_pos]
                if r["type"] == "task":
                    db.execute("DELETE FROM tasks WHERE id = ?", (r["id"],))
                    db.commit()
                    collapsed.discard(r["id"])
                    status_msg = f"Deleted task: {r['name']}"
                else:
                    db.execute("DELETE FROM steps WHERE id = ?", (r["id"],))
                    db.commit()
                    status_msg = f"Deleted: {r['text']}"

        # Cycle priority (steps only)
        elif ch == "p":
            if rows:
                r = rows[cursor_pos]
                if r["type"] == "step":
                    order = ["low", "medium", "high"]
                    idx = (order.index(r["priority"]) + 1) % 3
                    db.execute("UPDATE steps SET priority = ? WHERE id = ?", (order[idx], r["id"]))
                    db.commit()

        # Workspace switcher
        elif ch == "w":
            workspaces = db.execute("SELECT id, name FROM workspaces ORDER BY id").fetchall()
            options = list(workspaces) + [(-1, "+ New workspace")]
            picked = popup_select(stdscr, "Switch workspace", options, lambda r: r[1])
            if picked:
                if picked[0] == -1:
                    name = textbox_input(stdscr, "Workspace name:")
                    if name and name.strip():
                        name = name.strip()
                        now = datetime.now().isoformat()
                        if db.execute("SELECT 1 FROM workspaces WHERE name = ?", (name,)).fetchone():
                            status_msg = f"Workspace '{name}' already exists"
                        else:
                            cur = db.execute(
                                "INSERT INTO workspaces (name, created_at) VALUES (?, ?)", (name, now)
                            )
                            db.commit()
                            current_ws_id, current_ws_name = cur.lastrowid, name
                            collapsed.clear()
                            cursor_pos, scroll_offset = 0, 0
                            status_msg = f"Created workspace: {name}"
                else:
                    current_ws_id, current_ws_name = picked[0], picked[1]
                    collapsed.clear()
                    cursor_pos, scroll_offset = 0, 0
                    status_msg = f"Switched to: {current_ws_name}"


# ── Entry point ──────────────────────────────────────────────────────────────

def main():
    args = sys.argv[1:]
    if not args:
        curses.wrapper(tui_main)
        return

    db = get_db()
    resource = args[0]
    rest = args[1:]

    if resource == "workspace":
        cli_workspace(db, rest)
    elif resource == "task":
        cli_task(db, rest)
    elif resource == "step":
        cli_step(db, rest)
    else:
        cli_error(f"Unknown command: {resource}. Use workspace, task, or step.")


if __name__ == "__main__":
    main()
